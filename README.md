# quic-tls-work

Experiments and WIP based on projects:

- [tls](https://github.com/vincenthz/hs-tls) at commit `a2e831e2`

- [quic](https://github.com/kazu-yamamoto/quic) at commit `ccbc8b9a`

## Changes done

- Removed the QUIC extension from `ClientStatus` and `ServerStatus` and pass the
  value through a dedicated callback.  All the call does is set internal state
  with `setPeerParams` so this is safe to change.  The value is now set by a
  synchronous callback, so ahead of the previous MVar mechanism.

- Removed the secret info from `ClientStatus` and `ServerStatus` and pass this
  information through a callback.  Should be safe for the same reasons as
  previous change.

- TLS now has `stCryptLevel` to indicate what is the current encryption state in
  Tx/Rx directions.  When sending records, the QUIC record layer can annotate
  the record payload with the `CryptLevel`.  Doing this, it is now able to
  detect that pending content is for a different encryption level, so explicit
  flushing with `flushFlightIfNeeded` is not necessary anymore.  The normal TLS
  record layer continues to use non-annotated `ByteString` fragments, so the
  `RecordLayer` record is made polymorphic with an existential type.  The upside
  is that the polymorphic `bytes` type parameter prevents the library code from
  manipulating the content directly.  Values produced by `recordEncode(13)` have
  to go through `recordSendBytes` and nothing else.  On the `PacketFlightM`
  monad, this makes a rank 2 type parameter similar to ST monad.  The downside
  of the approach is that the added rigidity may block future experiments.  And
  the design is not always perfectly clean.  Some internal functions have a
  polymorphic result type, so need a `RecordLayer` argument.  But the functions
  also often need the `Context` argument for other purposes, like logging.  This
  adds repetition.

- For TLS 1.3 the calls `setTxState` and `setRxState` can infer the new
  encryption level from the secret type.  For versions before TLS 1.3 the
  encryption level is always `CryptMasterSecret` and set by `setMasterSecret`.

- Handshake fragments are now received through a synchronous `quicRecv` call
  instead of the `ClientContoller` and `ServerController` state machines.  The
  modification is safe because receiving is already reading from a message
  queue.  The `handshakeCheck` logic is not needed anymore.  `ClientNeedsMore`
  and `ServerNeedsMore` are removed, the existing Rx message parser detects
  incomplete parse and automatically calls `quicRecv` as many times as
  necessary.  `quicRecv` takes the current TLS encryption level to compare with
  the encryption level found by QUIC.

- Removing `handshakeCheck` required to move the control of TLS handshake
  previously executed by the Receiver thread to a different thread.  Otherwise
  the Receiver thread would hang when TLS messages are fragmented.  The Receiver
  is also the thread dispatching frames to the Crypto queue, and it would wait
  for itself.  A new thread is added for the duration of the last handshake
  steps, i.e. receiving client Finished (server) and receiving session tickets
  (client).

- The `quic` library had special logic to defer server processing of a Stream
  frame until connection is fully established.  This came from the fact that
  encryption level `RTT1Level` was set too early, when the server sends its
  flight, and before receiving the client flight at `Handshake` level.  But the
  variable `encryptionLevel` is used only by the Receiver, so it must map to the
  Rx encryption level.  Deferring the change to `RTT1Level` removes the need to
  handle Stream frames specially in the server side.  The global logic comparing
  incoming frames to the current level is enough.  One benefit now is that the
  logic can also apply to frames other than Stream.  For example a connection
  closure at `RTT1Level` will not be processed before the `Handshake` flight is
  processed.  This fully complies with the explanations in [RFC draft section
  5.7](https://tools.ietf.org/html/draft-ietf-quic-tls-27#section-5.7).

- In the Tx direction, handshake fragments are sent through `quicSend`.  This
  call takes a list of `ByteString` fragments annotated with encryption level.
  QUIC can wrap multiple frames together or not based on its own limits and
  fragmentation requirements.  Sending pushes to a queue, so moving everything
  to `quicSend` should be safe.  The data types `OutHndXXX` are all unified and
  replaced with `OutHandshake` generalization.  Except `OutEarlyData` which is
  kept as separate type, derived from the previous `OutHndClientHello`.  Early
  data does not go through TLS library but is generated by QUIC alone.

- The changes with `quicSend` and `quicRecv` removed `ClientNeedsMore` and
  `ServerNeedsMore` and the capability for QUIC to send necessary ACKs during
  handshake (commented as server "CI0" and client "three times rule").  To
  restore this we add an `IORef` and count how many `quicRecv` have been done
  since last `quicSend`.

- When testing the mapping between TLS and QUIC encryption levels in direction
  Rx, it was found the TLS server expected to receive records with the early
  traffic secret in 0-RTT handshakes.  Upon further inspection, the server logic
  in QUIC mode was actually skipping the pending action related to message
  EndOfEarlyData, however `setRxState` was left with `clientEarlySecret` instead
  of `clientHandshakeSecret`.  After fixing this, QUIC does not need encryption
  level `CryptEarlySecret` anymore, as one can expect.

- When TLS failures are reported by the API we use an ADT instead of throwing
  the `TLSError` as exception.  Handshake failures may originate in the QUIC
  record layer (in `quicRecv`) or in TLS itself.  The `TLSError` values are
  reported back to QUIC.  One key element here is to unwrap the `TLSException`
  to get the inner `TLSError`.  QUIC responsability is to notify the peer
  through network, and also report the local error condition to application
  code.  The peer still running handshake will notice an unexpected alert
  message in `quicRecv` and fail through the exact same steps.

- Eq instances on secret newtypes are removed because not time constant and not
  much useful for real applications.  The instances were used only for testing
  purpose and can be defined locally in the test suite.

- Package `quic` has requirements on `iproute` and `network-byte-order` that are
  not met by old Stackage LTS, so a lower version bound is added.

## Resulting design

The `ClientContoller` and `ServerController` state machines are still executed
but the all the actions and data transfers that previously existed are done
through the new callbacks.  The dialog `sync`/`control` between TLS and QUIC
only verifies the main steps of the handshake, ensuring synchronization between
threads, and reporting possible failures.

The main steps of the handshake are:

- FinishedSent: message "Finished" has been sent, endpoint is ready to send
  application traffic

- HandshakeComplete: peer message "Finished" has been received and verified,
  endpoint is ready to receive application traffic

- HandshakeConfirmed: TLS handshake is no more needed, session tickets have all
  been transferred

Out of those three defined steps, only two are really used.  For a client, steps
FinishedSent and HandshakeComplete are the same.  For a server, steps
HandshakeComplete and HandshakeConfirmed are the same.

QUIC uses the sychronization point `sync`/`control` to implement thread
separation and handle possible handshake failures:

- QUIC executes the first part of handshake in its main thread, until the
  "Finished" message is sent.  When a TLS error occurs, it is raised in the
  thread.

- QUIC executes the second part in a secondary thread.  When a TLS error occurs,
  it is logged by this thread but also generated as `InpError` message for the
  next `recvStream`.  For a server, the thread receives and verifies the client
  "Finished" message, then terminates.  For a client, the thread is an infinite
  loop to receive session tickets one by one and report a failure if any.  This
  thread is killed when QUIC has confirmation from the remote end (message
  HandshakeDone).

## To do

- Currently QUIC manages version negotation failures through `InpVersion` in the
  Crypto queue.  This is received by `quicRecv` in the TLS thread, so `tls`
  transforms it to `Error_Misc` and we loose the typing.  Maybe this part should
  not go through the Crypto queue, because it's not TLS related.  Alternatively,
  we could add a new constructor `Error_Some SomeException` to hold a
  `QUICError` (or any other type the record layer wishes).

- See if it is possible to avoid repeating the TLS cipher in the `SecretInfo`
  data types.  Similarly, handshake mode and negotiated protocol could be
  available from the TLS context through API.

- Verify if the new handshake ACK logic gives expected result.  Unclear if the
  frame should be sent before or after new receive.

- Verify if `quic` IORefs modified by the TLS to QUIC callbacks need atomic
  modify or not.

- More generic interface to insert/extract some content in TLS extensions.
  Could be applicable to TLS < 1.3 as well.  And to all message types.

- See if a better design can be found for polymorphic `RecordLayer`, to avoid
  repetition with `Content` and `RecordLayer` arguments some functions need.
